---
title: 树-应用
date: 2024-05-13
categories: [总]
---

# 递归遍历
## preorder
```cpp
void preorder(TreeNode *cur){
    if(cur==NULL) return;

    OPERATION(cur);
    preorder(cur->left);
    preorder(cur->right);
}
```
<!-- more -->

## inorder
```cpp
void inorder(TreeNode *cur){
    if(cur==NULL) return;
    
    inorder(cur->left);
    OPERATION(cur);
    inorder(cur->right);
}
```

## postorder
```cpp
void postorder(TreeNode *cur){
    if(cur==NULL) return;
    
    postorder(cur->left);
    postorder(cur->right);
    OPERATION(cur);
}
```

# 迭代遍历
## preorder
```cpp
void preorder(TreeNode *root){
    if(root==NULL) return;
    stack<TreeNode*> st;
    st.push(root);
    while(!st.empty()){
        TreeNode *cur = st.top(); st.pop();
        if(cur==NULL){ // 如果是空节点：对下一个pop的节点进行操作
            cur = st.top(); st.pop();
            OPERATION(cur);
        } else { // 如果不是空节点：先自身+空节点入栈作为标记，然后左右子节点入栈
            st.push(cur); st.push(NULL);
            if(cur->left) st.push(cur->left);
            if(cur->right) st.push(cur->right);
        }
    }
}
```

## inorder
```cpp
void inorder(TreeNode *root){
    if(root==NULL) return;
    stack<TreeNode*> st;
    st.push(root);
    while(!st.empty()){
        TreeNode *cur = st.top(); st.pop();
        if(cur==NULL){ // 如果是空节点：对下一个pop的节点进行操作
            cur = st.top(); st.pop();
            OPERATION(cur);
        } else { // 如果不是空节点：先"右"子节点入栈，然后自身+空节点入栈作为标记，最后"左"子节点入栈
            if(cur->right) st.push(cur->right);
            st.push(cur); st.push(NULL);
            if(cur->left) st.push(cur->left);
        }
    }
}
```

## postorder
```cpp
void inorder(TreeNode *root){
    if(root==NULL) return;
    stack<TreeNode*> st;
    st.push(root);
    while(!st.empty()){
        TreeNode *cur = st.top(); st.pop();
        if(cur==NULL){ // 如果是空节点：对下一个pop的节点进行操作
            cur = st.top(); st.pop();
            OPERATION(cur);
        } else { // 如果不是空节点：先"右左"子节点入栈，然后自身+空节点入栈作为标记
            if(cur->right) st.push(cur->right);
            if(cur->left) st.push(cur->left);
            st.push(cur); st.push(NULL);
        }
    }
}
```

## 层序
```cpp
void levelOrder(TreeNode *root){
    if(root==NULL) return;
    queue<TreeNode*> que;
    que.offer(root);
    while(!que.empty()){
        
    }
}
```

# 翻转树


# 求树高

# 判断是否是完全二叉树

# 文件结构

# 表达式
