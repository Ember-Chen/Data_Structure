---
title: 排序
date: 2024-05-13
categories: [总]
mathjax: true
---

# 基本思想
## 插入排序
### 直接插入排序
- 第n次插入时，已经有n-1个数据是有序存放的了，下一步要做的就是在n-1个数据中找一个合适的位置插入第n个数据使其保持有序
<!-- more -->
### 希尔排序
- 基于直接插入排序的改进
- 规定步长从大到小（最终步长是1），每个步长下对分组内的数据进行直接插入排序，等到最后一轮时整个序列相较于初始时已经更有序了，然后最后再进行一轮直接插入排序即可
- 开始时用大步长，目的是把后面较小的元素能够插入到跨度很大的前方

## 交换排序
### 冒泡排序
- 第n轮冒泡排序可以得到大小为n的有序序列，每轮两两交换把最大的元素换到右边界
### 快速排序
- 基于冒泡排序的改进
- 每次选择一个pivot分割序列为两部分，一部分小于pivot一部分大于pivot，每轮确定pivot在最终有序序列中的位置

## 选择排序
### 直接选择排序
- 遍历一遍整个序列，找出最大值，将其与最后一个元素交换，下次遍历的有边界变为倒数第二个元素，继续进行前面的操作。每轮都有一个最值被放到一端，和冒泡很像
### 堆排序
- 基于直接选择排序改进
- 建堆、选择堆顶元素、调整堆结构
- 无序数组建堆：从下到上，进行下滤； 插入堆：上滤； 弹出堆：下滤
- 归并排序基于分治法。合并树

## 其他排序
### 基数排序
- 对于整数的排序，
- 先按照个位数从小到大的顺序排放元素，得到新顺序的序列，再按照十位数从小到大的顺序在上一步的新顺序中再次排放元素，再按照百位数从小到大的顺序在上一步的新序列中再次排放元素
### 计数排序
每个数都是数组索引，把每个数的个数记录在对于数组位置上，然后遍历数组一个个取出非零单元的索引即可实现排序

# 算法性能总览
<img src="/img/algo.png">

# $O(nlogn)$排序算法间的比较
|算法|优点|缺点|
|---|---|---|
|快排|平均速度最快|递归调用栈空间花费O(logn)、排序不稳定|
|堆排序|额外占用空间最少：O(1)|不稳定
|归并排序|永远排序稳定、速度只略慢于快排|额外占用空间最大：O(n)|

# 稳定排序算法
- 直接插入排序（希尔排序也是插入排序，但是不稳定）
- 冒泡排序（快排也是交换排序，但是不稳定）
- 归并排序
- 基数排序
> **直接插入排序**和**冒泡排序**的相似处：排序过程中的每一轮操作，都不改变剩余未修改部分的内部顺序

# 适用场景分析
|算法|适用场景|
|---|---|
|直接插入排序|保证稳定性，内存有限；规模较小；已基本有序|
|归并排序|保证稳定性，内存充足，追求速度|
|快速排序|不需要稳定性，内存较充足，追求速度|
|基数排序|总体无序，但各子项相对有序|

# 直接插入排序-冒泡排序-选择排序
|分析角度|直接插入|冒泡|选择|
|---|---|---|---|
|时间复杂度最好最坏|在找到合适插入位置前，将已排序部分的尾部分整体平移，如果位置合适就不用平移|固定要遍历完所有未排序部分，但存在剪枝操作（是否交换）|固定要遍历完所有未排序部分，每次都找到最小/大的元素|
|稳定性|找插入位置过程中，已排序部分的尾部整体被平移，内部不移动|进行完所有两两交换后，不需要交换的部分内部不移动|每次找到未排序部分中的最值元素，然后将这个元素与“排序-未排序交界处的元素”直接交换，未排序部分内部会被打乱|

# 最好最坏情况分析
|算法|最好|最坏|
|---|---|---|
|直接插入排序|完全有序 O(n)|完全倒序 O(n^2)|
|冒泡排序|完全有序 O(n)|完全倒序 O(n^2)|
|快速排序|pivot可以平均分割左右数组 O(nlogn)|pivot是最大/最小值，树退化为链表 O(n^2)|
- 选择排序、归并排序：时间复杂度固定

# 各算法的implementation
- 参照个人笔记

# 堆排序
- 堆排序的过程中，对任一分支结点进行筛运算的时间复杂度为$O(logn)$，
整个堆排序过程的时间复杂度为$O(nlogn)$
- [e.g.] 通过构建最小堆对关键字序列 (49, 56, 69, 32, 28, 77, 89, 18, 46)进行排序，则排序过程中初始堆的序列状态为
    > 18 28 69 32 49 77 89 56 46
    > 采取**建堆**算法（先列出原始序列组成的二叉树，然后从下往上，进行下滤）
- [e.g.] 画出向小根堆中加入数据 4,2,5,8,3 时，每加入一个数据后堆的变化
    > 最终结果 23584

