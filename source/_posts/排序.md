---
title: 排序
date: 2024-05-13
categories: [总]
mathjax: true
---

# 基本思想
## 插入排序
### 直接插入排序
- 第n次插入时，已经有n-1个数据是有序存放的了，下一步要做的就是在n-1个数据中找一个合适的位置插入第n个数据使其保持有序
<!-- more -->
### 希尔排序
- 基于直接插入排序的改进
- 规定步长从大到小（最终步长是1），每个步长下对分组内的数据进行直接插入排序，等到最后一轮时整个序列相较于初始时已经更有序了，然后最后再进行一轮直接插入排序即可
- 开始时用大步长，目的是把后面较小的元素能够插入到跨度很大的前方

## 交换排序
### 冒泡排序
- 第n轮冒泡排序可以得到大小为n的有序序列，每轮两两交换把最大的元素换到右边界
### 快速排序
- 基于冒泡排序的改进
- 每次选择一个pivot分割序列为两部分，一部分小于pivot一部分大于pivot，每轮确定pivot在最终有序序列中的位置

## 选择排序
### 直接选择排序
- 遍历一遍整个序列，找出最大值，将其与最后一个元素交换，下次遍历的有边界变为倒数第二个元素，继续进行前面的操作。每轮都有一个最值被放到一端，和冒泡很像
### 堆排序
- 基于直接选择排序改进
- 建堆、选择堆顶元素、调整堆结构
- 无序数组建堆：从下到上，进行下滤； 插入堆：上滤； 弹出堆：下滤
- 归并排序基于分治法。合并树

## 其他排序
### 基数排序
- 对于整数的排序，
- 先按照个位数从小到大的顺序排放元素，得到新顺序的序列，再按照十位数从小到大的顺序在上一步的新顺序中再次排放元素，再按照百位数从小到大的顺序在上一步的新序列中再次排放元素
### 计数排序
每个数都是数组索引，把每个数的个数记录在对于数组位置上，然后遍历数组一个个取出非零单元的索引即可实现排序

# 算法性能总览
<img src="/img/algo.png">

# $O(nlogn)$排序算法间的比较
|算法|优点|缺点|
|---|---|---|
|快排|平均速度最快|递归调用栈空间花费O(logn)、排序不稳定|
|堆排序|额外占用空间最少：O(1)|不稳定
|归并排序|永远排序稳定、速度只略慢于快排|额外占用空间最大：O(n)|

# 稳定排序算法
- 直接插入排序（希尔排序也是插入排序，但是不稳定）
- 冒泡排序（快排也是交换排序，但是不稳定）
- 归并排序
- 基数排序
> **直接插入排序**和**冒泡排序**的相似处：排序过程中的每一轮操作，都不改变剩余未修改部分的内部顺序

# 适用场景分析
|算法|适用场景|
|---|---|
|直接插入排序|保证稳定性，内存有限；规模较小；已基本有序|
|归并排序|保证稳定性，内存充足，追求速度|
|快速排序|不需要稳定性，内存较充足，追求速度|
|基数排序|总体无序，但各子项相对有序|

# 直接插入排序-冒泡排序-选择排序
|分析角度|直接插入|冒泡|选择|
|---|---|---|---|
|时间复杂度最好最坏|在找到合适插入位置前，将已排序部分的尾部分整体平移，如果位置合适就不用平移|固定要遍历完所有未排序部分，但存在剪枝操作（是否交换）|固定要遍历完所有未排序部分，每次都找到最小/大的元素|
|稳定性|找插入位置过程中，已排序部分的尾部整体被平移，内部不移动|进行完所有两两交换后，不需要交换的部分内部不移动|每次找到未排序部分中的最值元素，然后将这个元素与“排序-未排序交界处的元素”直接交换，未排序部分内部会被打乱|

# 最好最坏情况分析
|算法|最好|最坏|
|---|---|---|
|直接插入排序|完全有序 O(n)|完全倒序 O(n^2)|
|冒泡排序|完全有序 O(n)|完全倒序 O(n^2)|
|快速排序|pivot可以平均分割左右数组 O(nlogn)|pivot是最大/最小值，树退化为链表 O(n^2)|
- 选择排序、归并排序：时间复杂度固定

# 各算法的implementation
- 参照个人笔记


# 例题
## 堆排序
- 堆排序的过程中，对任一分支结点进行筛运算的时间复杂度为$O(logn)$，
整个堆排序过程的时间复杂度为$O(nlogn)$
- [e.g.] 通过构建最小堆对关键字序列 (49, 56, 69, 32, 28, 77, 89, 18, 46)进行排序，则排序过程中初始堆的序列状态为
    > 18 28 69 32 49 77 89 56 46
    > 采取**建堆**算法（先列出原始序列组成的二叉树，然后从下往上，进行下滤）
- [e.g.] 画出向小根堆中加入数据 4,2,5,8,3 时，每加入一个数据后堆的变化
    > 最终结果 23584

- [e.g.] 设一组初始记录关键字序列为 (55,63,44,38,75,80,31,56)，则利用筛选法建立的初始堆为
    > 31,38,54,56,75,80,55,63
    > 默认的堆是小顶堆（默认排序是ASC）

- [e.g.] 设有 n 个待排序的记录关键字，则在堆排序中需要（）个辅助记录单元
    > 1
    > 只需要1个空间用于交换

- [e.g.] 设初始记录关键字序列为 (K1，K2，…，Kn)，则用筛选法思想建堆必须从第__个元素开始进行筛选
    > n/2
    > 
    > 即最后一个节点n的父节点

- [e.g.] 设一组初始记录关键字序列 (k1, k2,...--, k,) 是堆，则对 i=1，2,, n/2 而言满足的条件为
    > $k_i<=k_{2i} \space and \space k_i<=k_{2i+1}$

## 快速排序
- [e.g.] 设一组初始记录关键字序列 (5,2,6,3,8)，以第一个记录关键字 5 为基准进行一趟快速排序的结果为 ()
    > 32568
    > 过程：52638 -> 32658 -> 32568


## 其他排序
- [e.g.] 设一组初始记录关键字序列为 (45,80,48,40,22,78),则分别给出第 4 趟简单选择排序和第 4 趟直接插入排序后的结果。
    > 简单选择排序：初始 -> 22,80,48,40,45,78 -> 22,40,48,80,45,78 -> 22,40,45,80,48,78 -> 22,40,45,48,80,78
    > 直接插入排序：初始 -> 45,80,48,40,22,78 -> 45,80,48,40,22,78 -> 45,48,80,40,22,78 -> 40,45,48,80,22,78

- [e.g.] 设一组初始关键字记录关键字为 (20, 15, 14, 18, 21, 36, 40, 10),则以 20 为基准记录的一趟快速排序结束后的结果为（）
    > 10,15,14,18,20,36,40,21
    > 初始 -> 10,15,14,18,21,36,40,20 -> 10,15,14,18,20,36,40,21

- [e.g.] 设一组初始记录关键字序列为 (345，253，674，924，627)，则用基数排序需要进行 ()趟的分配和回收才能使得初始关键字序列变成有序序列
    > 3
    > 个位，十位，百位

- [e.g.] 设一组初始记录关键字序列为 (50， 40，95，20， 15，70， 60，45)，则以增量 d=4 的一趟希尔排序结束后为()
    > 初始 -> 15,40,60,20,50,70,95,45

- [e.g.] 设一组初始记录关键字序列为 (25,50,15,35,80,85,20,40,36,70),其中含有个长度为 2 的有序子表,则用归并排序的方法对该记录关键字序列进行一趟归并后的结果为 ()
    > 15,25,35,50,20,40,80,85,36,70
    > (25,50,15,35) -> 15,25,35,50
    > (80,85,20,40) -> 20,40,80,85

- [e.g.] 一趟排序结束后不一定能够选出一个元素放在其最终位置上的是 ()
（A）堆排序 (B) 冒泡排序（C） 快速排序 (D) 希尔排序
    > 快排的每一趟是可以确定pivot的最终位置的