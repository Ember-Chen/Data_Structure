---
title: 二分查找
date: 2024-05-13
categories: [总]
mathjax: true
---


# 二分查找代码
```cpp
int search(vector<int>& nums, int target) {
    int left=0, right=nums.size()-1;
    while(left<=right){ // 左闭右闭
        int mid = (right-left)/2+left;
        if(nums[mid]==target) 
            return mid;
        else if(nums[mid] < target) 
            left = mid+1;
        else 
            right= mid-1;
    }
    return -1;
}
```

<!-- more -->

# 查找路径判断
- [e.g.] 若有 18 个元素的有序表存放在一维数组 A[19]中，第一个元素放 A[1]中，现进行二分查找，则查找 A[3]的比较序列的下标依次为
A.1，2，3   B.9，5，2，3    C.9，5，3   D.9，4，2，3
// D

- [e.g.] 折半查找有序表（4，6，10，12，20，30，50，70，88，99），若查找元素 60，则它将依次与表中元素（ ）比较大小，查找结果是失败。
    > 20 70 30 50

- [e.g.] 已知有序表（6, 10, 17, 19, 26, 33, 49, 51, 68），当折半查找值为 19 的元素时，查找成功的比较次数为
    > 4

# 二分查找判定树画法

- [e.g.] 依次输入表（38，52，25，74，68，16，30，54，90，72）中的元素，生成一棵二叉排序树。若每个元素的查找概率相等，试计算该二叉排序树的平均查找长度
    > <img src="/img/bst1.png">
    > 
    > $ASL=\frac{1×1+2×2+3×3+4×2+5×2}{10} = 3.2$

# 计算BST的ASL
## 算法
- $ASL_{成功} = \frac{\sum{节点的比较次数}}{节点总个数}$
- $ASL_{失败} = \frac{\sum{空指针处的比较次数}}{空指针总个数}$
    > 深度为i的空指针处的比较次数 = i-1
    > i.e. 空指针自身不算一次比较

## 例题
- [e.g.] 求解$ASL_{成功}$
    ```pseudocode
                 36
            /        \
            24        52
            / \       /  \
          10   30    41  90
        / \       /    /
       8  12     38   61
    ```
    > $ASL_{成功} = (1×1 + 2×2 + 3×4 + 4×4) / 11 = 33 / 11 = 3$

- [e.g.] 求解$ASL_{成功}$
    ```pseudocode
                 36
            /           \
           24            52
          /  \         /    \
        10    30      41     90
        / \    / \    /  \    / \
       8  12  28  31 38  42  61  91
    ```
    > $ASL_{成功} = (1×1 + 2×2 + 3×4 + 4×8) / 15 = 49/15$

- [e.g.] 求解$ASL_{失败}$
    <img src="/img/bst2.png">
    > $ASL_{失败} = \frac{3×4+4×8}{12} = 3.67$

