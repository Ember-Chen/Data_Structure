---
title: 循环队列
date: 2024-05-13
categories: [总]
---

# 多一个空间，避免歧义（常考）
## front指针偏前
- front指向队头的前一个；rear指向队尾元素

<!-- more -->

```cpp
// 入队
void push(int val){
    rear = (rear+1)%M;
    q[rear] = val;
}

// 出队
int pop(){
    front = (front+1)%M;
    return q[front];
}
// 判断空
bool empty(){
    return front==rear;
}
// 判断满
bool full(){
    return (rear+1)%M==front;
}
// 得大小
int size(){
    return (rear - front + M)%M;
}
```
// *还是不太清楚，之后详细搞懂

## rear指针偏后
- front指向队头元素；rear指向队尾的后一个

```cpp
// 入队
void push(int val){
    q[rear] = val;
    rear = (rear+1)%M;
}
// 出队
int pop(){
    int res = q[front];
    front = (front+1)%M;
    return res;
}
// 判断空
bool empty(){
    return front==rear;
}
// 判断满
bool full(){
    return (rear+1)%M==front;
}
// 得大小
int size(){
    return (rear - front + M)%M;
}
```

# 利用size变量（常考）
- `size==0`栈空；`size==M`栈满
- `front`指向队头，`rear`指向队尾
- `front`,`rear`,`size`之间的相互关系
    - 由`front`和`size`得到`rear`：`rear = (front+(size-1))%M`
    - 由`rear`和`size`得到`front`：`front = (rear-(size-1))%M`
    > - 当`size==0`时，`rear==front-1`
    > - 当`size==1`时，`front==rear`


# 使用tag指示
- 入栈操作后，设置`tag=0`
- 出栈操作后，设置`tag=1`
- 结合tag判断栈满/栈空

```cpp
class Stack{
    int front,end;
    int M; // 容量
    int tag;
    Stack(int _M){
        M = _M;
        front = 0; end = 0;
    }
    ...
}
```

# 例题

- [e.g.] 设顺序循环队列 `Q[0:M-1]`的头指针和尾指针分别为 F 和 R,头指针 F 总是指向队头元素的前一位置,尾指针 R 总是指向队尾元素的当前位置,则该循环队列中的元素个数为 ()
(A) R-F (B) F-R (C)(R-F+M)%M (D)(F-R+M)%M
    > C

- [e.g.] 循环队列用数组 A[0，max-1]存放其元素值，已知其头尾指针分别是 front 和 rear，则该队列满的条件是
    > `(rear+1)%max == front`
    > 默认是采用"多一个空间"的实现方式

- [e.g.] 假设以数组 seqn［m］存放循环队列的元素，设变量 rear 和 quelen 分别指示循环队列中队尾元素的位置和元素的个数。写出一般情况下队头元素位置的表达式
    > `front = (rear-quelen+m) % m`

