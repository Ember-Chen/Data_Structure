---
title: 广义表
date: 2024-05-13
categories: [总]
---

# 表头/表尾计算
- **表头**可以是原子或列表，**表尾**必定是列表
- 表尾: 除表头外的**剩余元素**，组成的1个**新的广义表**
- 空表没有表头，表尾

<!-- more -->

- > [e.g.] 广义表`A=(a,b,(c,d),(e,(f,g)))`，则`Head(Tail(Head(Tail(Tail(A))))) = ?`

    > d
    > x1=Tail(A)=(b,(c,d),(e,(f,g)));
    > x2=Tail(x1)=((c,d),(e,(f,g)));
    > x3=Head(x2)=(c,d);
    > x4=Tail(x3)=(d);
    > x5=Head(x4)=d


- > [e.g.] 表头和表尾均为空表的广义表是（   ）
    A. (( ), ( ))      B. ((( )))      C. (( ))      D. ( )
    > C
    > A选项: 表尾是`( () )`; 不是空表

- [e.g.] 记 D = ( E, F ) =  ((a, (b, c))，F )
    > Head( D ) = E; Tail( D ) = ( F )
    > Head( E ) = a; Tail( E ) = ( ( b, c) )
    > Head( (( b, c)) ) = ( b, c); Tail( (( b, c)) ) = ( )
    > Head( ( b, c) ) = b; Tail( ( b, c) ) = ( c )
    > Head( ( c ) ) = c; Tail( ( c ) ) = ( )

# 深度/广度计算
## 广义表的广度
- 最外层包含的元素个数

## 算法
- 拆去最外层括号，观察有多少个元素

## 广义表的深度
- 所含括弧的**重数**
- 递归定义的广义表，深度为无穷
### 算法1：拆最外层括号法
1. 递归地拆最外层括号
2. 原子忽略不计
3. 拆解到为null为止
4. 总共拆了几层括号，深度就为几

### 算法2：统计最大栈高法
1. 从头开始遍历广义表各个括号
2. 遇到`(`则入栈（栈高+1），遇到`)`则出栈（栈高-1）
3. 记录过程中**最大**出现过的栈高 


## 例题
- [e.g.] 广义表`((a, ()), (b, (c)), (( )))`的长度和深度分别是(   )
    > 3,3
    > - 广度的计算
    >   - 拆去最外层括号，得到`(a,())`,`(b,(c))`,`(())`
    >   - 因此广度为3
    > - 深度的计算
    >   1. 拆第1层括号，得到`(a,()),(b,(c)),(())`
    >   2. 拆第2层括号，得到`(),(c),()`（忽略原子）
    >   3. 拆第3层括号，得到`null`（忽略原子）
    >   
    >   因此总共有3层括号，深度为3

- [e.g.] 广义表`((a)，((b)，c)，(((d))))`的长度和深度分别是多少？
    > 3,4

- [e.g.] `LS={LS,{}}`的深度
    > 无穷

# 广义表-二叉树
- 括号前的字母：该节点的值；括号内的元素：该节点的子节点们
- [e.g.] 假定一棵树的广义表表示为 `A(C，D(E，F，G)，H(I，J))`，则树中所含的结点数为__个，树的深度为__，树的度为__
    > 9 3 3